--- src/spvw_sigsegv.d.orig	2008-05-25 12:10:38.000000000 -0400
+++ src/spvw_sigsegv.d	2008-10-20 22:06:12.952240950 -0400
@@ -69,29 +69,8 @@
 
 #ifdef NOCOST_SP_CHECK
 
-local void stackoverflow_handler (int emergency, stackoverflow_context_t scp) {
-  if (emergency) {
-    fprintf(stderr,GETTEXTL("Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!"));
-    fputs("\n",stderr);
-    print_mem_stats();
-  }
-  /* Libsigsegv requires handlers to restore the normal signal mask
-   prior to resuming the application from the stack overflow handler. */
- #ifdef UNIX
-  /* Unblock signals blocked by libsigsegv/src/handler-unix.c:install_for()
-   Alternatively unblock all signals */
-  { var sigset_t sigblock_mask;
-    /* sigemptyset(&sigblock_mask);
-     sigaddset(&sigblock_mask,SIGSEGV);
-     sigaddset(&sigblock_mask,SIGBUS);
-     sigaddset(&sigblock_mask,SIGINT);
-     sigaddset(&sigblock_mask,SIGHUP);
-     and QUIT, TERM, PIPE, ALRM, IO and many more */
-    sigfillset(&sigblock_mask);
-    sigprocmask(SIG_UNBLOCK,&sigblock_mask,NULL);
-  }
- #endif
-  sigsegv_leave_handler();
+local void stackoverflow_handler_continuation (void* arg1, void* arg2, void* arg3) {
+  stackoverflow_context_t scp = (stackoverflow_context_t) arg1;
  #ifdef HAVE_SAVED_STACK
   /* Assign a reasonable value to STACK: */
   if (saved_STACK != NULL) {
@@ -172,6 +151,36 @@
   SP_ueber();
 }
 
+local void stackoverflow_handler (int emergency, stackoverflow_context_t scp) {
+  if (emergency) {
+    fprintf(stderr,GETTEXTL("Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!"));
+    fputs("\n",stderr);
+    print_mem_stats();
+  }
+  /* Libsigsegv requires handlers to restore the normal signal mask
+   prior to resuming the application from the stack overflow handler. */
+ #ifdef UNIX
+  /* Unblock signals blocked by libsigsegv/src/handler-unix.c:install_for()
+   Alternatively unblock all signals */
+  { var sigset_t sigblock_mask;
+    /* sigemptyset(&sigblock_mask);
+     sigaddset(&sigblock_mask,SIGSEGV);
+     sigaddset(&sigblock_mask,SIGBUS);
+     sigaddset(&sigblock_mask,SIGINT);
+     sigaddset(&sigblock_mask,SIGHUP);
+     and QUIT, TERM, PIPE, ALRM, IO and many more */
+    sigfillset(&sigblock_mask);
+    sigprocmask(SIG_UNBLOCK,&sigblock_mask,NULL);
+  }
+ #endif
+ #if LIBSIGSEGV_VERSION >= 0x0206
+  sigsegv_leave_handler(stackoverflow_handler_continuation,scp,NULL,NULL);
+ #else
+  sigsegv_leave_handler();
+  stackoverflow_handler_continuation(scp,NULL,NULL);
+ #endif
+}
+
 /* Must allocate room for a substitute stack for the stack overflow
  handler itself. This cannot be somewhere in the regular stack,
  because we want to unwind the stack in case of stack overflow. */
